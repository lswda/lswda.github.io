---
title: 冒泡排序
layout: post
categories: 算法学习
tags: 算法 排序
---
参考博客：

https://www.cnblogs.com/shiluoliming/p/6740585.html
https://www.cnblogs.com/jiqingwu/p/bubble_sort_analysis.html

### 冒泡排序（Bubble Sort）

冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。
它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。

```python
import time

data_set = [12, 1, 24, 45, 61, 21, 6, 32]  # 8

loop_count = 0

start_time = time.clock()

for j in range(len(data_set)):
    for i in range(len(data_set) - j - 1):
        if data_set[i] > data_set[i+1]:
            tmp = data_set[i]
            data_set[i] = data_set[i+1]
            data_set[i+1] = tmp
        loop_count += 1
        print("第", i, "趟： ", data_set)
    print("-----------------------------")

elapsed = (time.clock() - start_time)
print(data_set)
print("times is :", loop_count)
print("Total time is :", elapsed)
```

输出结果：

```
第 0 趟：  [1, 12, 24, 45, 61, 21, 6, 32]
第 1 趟：  [1, 12, 24, 45, 61, 21, 6, 32]
第 2 趟：  [1, 12, 24, 45, 61, 21, 6, 32]
第 3 趟：  [1, 12, 24, 45, 61, 21, 6, 32]
第 4 趟：  [1, 12, 24, 45, 21, 61, 6, 32]
第 5 趟：  [1, 12, 24, 45, 21, 6, 61, 32]
第 6 趟：  [1, 12, 24, 45, 21, 6, 32, 61]
-----------------------------
第 0 趟：  [1, 12, 24, 45, 21, 6, 32, 61]
第 1 趟：  [1, 12, 24, 45, 21, 6, 32, 61]
第 2 趟：  [1, 12, 24, 45, 21, 6, 32, 61]
第 3 趟：  [1, 12, 24, 21, 45, 6, 32, 61]
第 4 趟：  [1, 12, 24, 21, 6, 45, 32, 61]
第 5 趟：  [1, 12, 24, 21, 6, 32, 45, 61]
-----------------------------
第 0 趟：  [1, 12, 24, 21, 6, 32, 45, 61]
第 1 趟：  [1, 12, 24, 21, 6, 32, 45, 61]
第 2 趟：  [1, 12, 21, 24, 6, 32, 45, 61]
第 3 趟：  [1, 12, 21, 6, 24, 32, 45, 61]
第 4 趟：  [1, 12, 21, 6, 24, 32, 45, 61]
-----------------------------
第 0 趟：  [1, 12, 21, 6, 24, 32, 45, 61]
第 1 趟：  [1, 12, 21, 6, 24, 32, 45, 61]
第 2 趟：  [1, 12, 6, 21, 24, 32, 45, 61]
第 3 趟：  [1, 12, 6, 21, 24, 32, 45, 61]
-----------------------------
第 0 趟：  [1, 12, 6, 21, 24, 32, 45, 61]
第 1 趟：  [1, 6, 12, 21, 24, 32, 45, 61]
第 2 趟：  [1, 6, 12, 21, 24, 32, 45, 61]
-----------------------------
第 0 趟：  [1, 6, 12, 21, 24, 32, 45, 61]
第 1 趟：  [1, 6, 12, 21, 24, 32, 45, 61]
-----------------------------
第 0 趟：  [1, 6, 12, 21, 24, 32, 45, 61]
-----------------------------
-----------------------------
[1, 6, 12, 21, 24, 32, 45, 61]
times is : 28
  elapsed = (time.clock() - start_time) 调用clock函数此处有error
Total time is : 0.000774028999999999
```

可以看出每一次外部循环结束后都可以筛出一个最大值，例如第一次是最大值61，第二次是次大值45，以此类推。也可以看出在倒数第三次循环的时候，第0趟已经将列表值排列好，但是后边仍然会进行未完成的循环，也就是无效运算。

第10行：

-1 是因为每次比对的都 是i 与i +1,不减1的话,最后一次对比会超出list 获取范围,-j是因为,每一次大loop就代表排序好了一个最大值,放在了列表最后面,下次loop就不用再运算已经排序好了的值了

### 时间复杂度

时间复杂度分析。其外层循环执行 N - 1次。内层循环最多的时候执行N次，最少的时候执行1次，平均执行 (N+1)/2次。时间复杂度O(n²)



### 改进

我们发现当倒数第三次外层循环完成后，排序就完成了。后面的循环只有比较，而没有交换。
当这次外层循环中，相邻的元素没有发生交换，就说明数组已经是有序的了，这时可以跳出循环。这样，我们可以设置一个布尔变量，记录一次外层循环中是否发生交换，如果未发生交换，算法就返回。

```python
for j in range(len(data_set)):
    done = 0
    for i in range(len(data_set) - j - 1):  # -1 是因为每次比对的都 是i 与i +1,不减1的话,最后一次对比会超出list 获取范围,
                                            # -j是因为,每一次大loop就代表排序好了一个最大值,放在了列表最后面,下次loop就不用再运算已经排序好了的值了
        if data_set[i] > data_set[i+1]:
            tmp = data_set[i]
            data_set[i] = data_set[i+1]
            data_set[i+1] = tmp
            done = 1
        loop_count += 1
        print("第", i, "趟： ", data_set)
    if (done == 0):
        break
    print("-----------------------------")
```

输出结果：

```python
第 0 趟：  [1, 12, 24, 45, 61, 21, 6, 32]
第 1 趟：  [1, 12, 24, 45, 61, 21, 6, 32]
第 2 趟：  [1, 12, 24, 45, 61, 21, 6, 32]
第 3 趟：  [1, 12, 24, 45, 61, 21, 6, 32]
第 4 趟：  [1, 12, 24, 45, 21, 61, 6, 32]
第 5 趟：  [1, 12, 24, 45, 21, 6, 61, 32]
第 6 趟：  [1, 12, 24, 45, 21, 6, 32, 61]
-----------------------------
第 0 趟：  [1, 12, 24, 45, 21, 6, 32, 61]
第 1 趟：  [1, 12, 24, 45, 21, 6, 32, 61]
第 2 趟：  [1, 12, 24, 45, 21, 6, 32, 61]
第 3 趟：  [1, 12, 24, 21, 45, 6, 32, 61]
第 4 趟：  [1, 12, 24, 21, 6, 45, 32, 61]
第 5 趟：  [1, 12, 24, 21, 6, 32, 45, 61]
-----------------------------
第 0 趟：  [1, 12, 24, 21, 6, 32, 45, 61]
第 1 趟：  [1, 12, 24, 21, 6, 32, 45, 61]
第 2 趟：  [1, 12, 21, 24, 6, 32, 45, 61]
第 3 趟：  [1, 12, 21, 6, 24, 32, 45, 61]
第 4 趟：  [1, 12, 21, 6, 24, 32, 45, 61]
-----------------------------
第 0 趟：  [1, 12, 21, 6, 24, 32, 45, 61]
第 1 趟：  [1, 12, 21, 6, 24, 32, 45, 61]
第 2 趟：  [1, 12, 6, 21, 24, 32, 45, 61]
第 3 趟：  [1, 12, 6, 21, 24, 32, 45, 61]
-----------------------------
第 0 趟：  [1, 12, 6, 21, 24, 32, 45, 61]
第 1 趟：  [1, 6, 12, 21, 24, 32, 45, 61]
第 2 趟：  [1, 6, 12, 21, 24, 32, 45, 61]
-----------------------------
第 0 趟：  [1, 6, 12, 21, 24, 32, 45, 61]
第 1 趟：  [1, 6, 12, 21, 24, 32, 45, 61]
[1, 6, 12, 21, 24, 32, 45, 61]
times is : 27
Total time is : 0.0
```

-----------

关于error：

我的python是3.7所以用time模块的clock函数会有错误

<b>DeprecationWarning: time.clock has been deprecated in Python 3.3 and will be removed from Python 3.8: use time.perf_counter or time.process_time instead</b>

time.clock()

用以浮点数计算的秒数返回当前的CPU时间，用来衡量不同程序的耗时，比time.time()更有用

python3.3以后不被推荐使用，该方法依赖操作系统，建议使用per_counter(返回系统运行时间)或

process_time(返回进程运行时间)代替